# 
bash, js, python, golangでバッチ処理を書き比べ

## なぜバッチを書くのか？

サーバーだったら、

1. 本番サーバーのバックアップを取りたい

1ヶ月分のバックアップをどこかに移動させるとか。
本番サーバーの最新の内容を毎朝06:00に自動で適用するとか、開発サーバーに
昔は容量圧迫するから3ヶ月分や半年前までは保存して、
特定の日に消すというところが多かったけど、
最近はとりあえず残しとこう。というところが多い。

これも本番から開発にデータ移すときは
プライバシーの問題で
メールアドレスを全て会社のdeveloper@co.jp
メール送信のテスト用アカウントにする。
みたいなアカウントにして
パスワードを全てパスワードに上書きするとか。

これをバッチ処理でやっておくと、間違って
お客さんにメール飛ばないから安心間がある。


名前もID+テスト太郎にupdateしておくと、
誰のデータかわからんようになるから
これやっとくとオペミス減って楽。


2. メールの自動送信

決済日に送信
これやらないとお客さんがよくわからないけど
決済されてる、詐欺じゃ無い？!となるので必須。
実際何でもないのでクレジットカード会社に
へんな決済されていると連絡してそれでキャンセルされたから、
もう一度決済してもらうことになった事例を前経験しました。

クレジットカードの支払いキャンセルされたかどうかは、
決済代行システムを使ってる場合はそっちで支払いキャンセルされたかどうか
確認するしかないから、事務作業になる。
stripeとかだとクレジットカードキャンセルされたとかで、
なんらかのリクエスト送ってくれたりするのかな？
もし知ってる人いたら後で教えて欲しいです。



クレジットカードの会社とかは決済日の何日前とかに
送ったりと、決済日の両方送ったりする。

新聞とかそれ系のWebアプリで多い。
定期的に読ませたい新しい記事を読ませたいから
サブスクリプション契約してやったーじゃなくて、
じゃなくて、サブスクリプションって継続させることに意味があるので、
契約したから、こういう記事が読めるというメリットありますよ。
ということで新しい記事の要約を送ったり。
これは無料会員に対しても送ること多い。

これもrailsやlaravel側のメール送信用のライブラリ使ったらいいのでは無いか？
という人も結構いると思うんですが、
それをやるとバッチ処理がwebアプリケーションに決め打ちされてしまうのと、
コントローラーのいろんな部分でメール送信の実装が出てくるので、管理がしんどくなる。
あと何らかの設定ミスだったりバグでメールが送れなかった場合、
結局バッチから送るということになると思うので
2度手間じゃ無いかと。


メールの文書って結局開発側で決めれなくて、経営陣やそれにつぐ人に聞かないとダメな
ことが多いし、場合によってはどんなメールが送信されるのか管理しときたいということがあって、
それだとコントローラーのいろんな部分にメール送信の実装が出てくる作りだと厳しい。

メール送信の実装をバッチ側に隠蔽して、
そこからDBを見て送信見たいにすると良い。
バッチ側にメール送信の実装を移しておいて、
Webアプリからバッチ処理(api)叩くようにしておいて、

そういう使い方するなら、
オンプレならイベント
クラウドならキューに入れてという使い方になるのかな？

ここらへんはPMとよく相談してから決めたらいいと思います。


データ量が多くなったら、
お名前.comが

3. 外部システムとの連携
15分おきにどこかのシステムのデータ見に行かないといけないとか。


これは最近増えた要件だと思うんですが、

3. 社内SNSに投稿

slackに決済データや予定の人を投稿
経営者と経理の人間だけ見れるチャンネルを作って
決済日に何人決済された？
金額合ってる？
特に新しい機能を追加したときは必ず必要な作業になります。

異常系だった場合アラートとして送信。
さっき描いた15分分おきにシステムのデータ見に行くとかもそう描いてたら、
15分おきにslackに投稿するようにしていて、
ちゃんとデータ連携していなかったら、メンションつけてERRORみたいな
メッセージでるからエンジニア読んでと
しといたら、
運用側もスムーズ。

それ以外にも色々あるんですが、
定期的に聞かれること、共有が決まってるやつは全部、
アプリ作ってチャンネル見といてで済みます。

これやらないと定期的にエンジニアの

ベンチャーのエンジニア字面だけ見るとキラキライメージだけどたぶん過労死する
その実一人で開発と運用とヘルプデスクやってるところザラですし。

実を言うとヘルプデスク的な仕事は大体、
slackのアプリにして事務と連携したら解決できるんですよ。

大手Sierが作ったプロジェクトでこれ売り込めたらいいな
って思ってたんですが、これ売り込みたかったらSier飛ばしてエンドに売り込まないといけないから売り込むの難しいと
わかって放置してる。

ヘルプデスク的な仕事は実はほとんど無くせる
というのが現実。

クライアント側

これはバッチ処理というよりコマンドになるんですが、

1. 設定を切り替えたい。

例えば、gcpやawsの設定を環境変数で
.bash_profileで見ていて、案件事や開発環境のDB


2. 便利ツール作る。

自分がよくやってる行動からこう言うのあったら楽だなとか。
.envファイルをbash上で読み込んで環境変数にする物が
無いから欲しいと思って自分は設定したり、

いちいちブラウザ立ち上げてdeepl翻訳使うの面倒だから、
deepl翻訳のapiを叩いて翻訳結果見たいとか。
slackに投稿

3. ローカルから開発用と本番用のコマンド作って

使い分けるとか。

本番のデータ見に行かないとダメなこと普通にあるので。

## バッチ処理に何が求められるか

ここから
一番求められるのはこれだと思ってて、

1. バグ作りづらい(堅牢かどうか、デバッグ、テストが楽かどうか)

これが何でかと言ったら、バッチ処理って
全部が全部ビジネスロジックなんですよ。

例えばさっき行ったメール送信で
間違って支払いが滞っている
みたいなメールが送信されたら、
システムの信用がガクンと落ちます。

これが怖いから、本番環境にバッチテスト用の
アカウント作るということはザラやと思います。
経営者のアカウントで実際少額支払ってもらってバッチ動くか
の確認とかも割とやって流ところ多いと思います。

個人的には純粋なプログラミングスキルだけで言うと、
railsとかframeworkできるじゃなくて、自分でデータ設計や関数の設計含めた
プログラミングスキルですね。
ここに一番優秀な人入れるか優秀な人主導にしといた方がいいと思います。

2. 速度

次に求められるのが速度で、
例えば、外部決済システムと連携してその結果を自分たちのシステムに取り込む。
こういう事している会社さん多いと思います。
決済結果わかったら、すぐ請求書作成なり画面で見えるようにして欲しいと
その場合だったら、速度が遅いとバッチ処理が落ちた場合は請求が間に合わなくなったり、
請求書のロジック変えたから確認したいというときに、ちゃんと確認する時間が取れなくなったりします。

なので、速度も割と重要だと思います。


3. 保守性

そのバッチ処理、言語のバージョンあげたらうごなくなったりしないか？
データの要件変わった時に混乱しないかというのがあります。
これは

個人的にはバッチはOrm使うんじゃなくてsql使った方がいいと思うんですけど、
今30代前半以前のエンジニアでsqlちゃんとかける人がいないって問題があるんで
orm使うというのはまあ仕方ないかなというのはあります。

Orm使うんが全部悪いと言わないですけど、ビジネス的な要件に合っているか
は考えてから採用した方がいいです。
自分の経験になりますが、OrmでしかDbさわれない人がビジネスサイドの要件の変更とか、
ビジネスサイドの意見、速度の問題に対応できなくて、
パンクして飛んだ人を周りで経験してるので。

4. 冪等性

これはプログラミング言語側というか、
データ設計の問題なんで、table設計がヤバいとか。
ここでは触りだけ。

何回やっても同じ状態になると言う事。
正直これは全て冪等にはできないと思うんですが、
バッチ処理自体が落ちる事があるのと、Webサービスがうまく動かなかった時に
手動でやる事があることを考えると基本的に冪等にすべき。

さっき行ったメールのやつだったら、決済確定処理が走ってメールも送った場合は、
メール送ったという回数をつけるとか。
これがわかってると、db側のtableはinsert じゃなくて、upsertが妥当な作りになるとか。
table設計の方針も決まります。
frameworkのバージョンによってはupsertはOrmだと対応してないやつや厳密には
upsertになってないやつもあるからあまりOrmはお勧めしない。
業務的には妥当な要件だから、これはormこねくり回すんじゃなくてSQL書いた方がいいです。
特定のアプリケーションに依存する書き方せん方がいい。
メールのテンプレートを保存しとくテーブル、どのタイミングでメールが送信されるか
そのメールはどのタイミングで自動的に送信されるか
(特定の時間、契約時、決済時)
中規模以上になったら、業務上の要件で
どのタイミングでどういうメールが送られるか
事務と経営側で管理しときたいっていうのを大抵言われます。
画面で見えるようにしといて欲しいと。
メールのテンプレートが20件とかならいいけど
80件ならエンジニアでも

決済だけでも
初回決済と2回目以降の決済は分けて欲しい、
都度買っている人とサブスクリプションで決済のメール分けて欲しいとか

決済成功しました。
クレジットカードの引き落とし失敗しました。

本人確認書類で、
受け付けました。
なになに
退会処理とか、


意外とメールのテンプレートが必要になるし、
これらをソースコードにベタ書きできない。
たまにあるのがif文でメールの内用分けるというやつで
後でメールの要件、変更追加間違いなくあるのと、
メールのテンプレートの内用と、実際メール送った内用が
食い違うから、
これはデバッグクソむずくなるのでやめた方がいい。
運用エンジニア死にます。

これ一度経験して、自分が割食う立場だったんですけど、
結論から言うと全部作り直した方が早かったです。

なんやかんやで中規模以上ならメールテンプレート80件いくとかは
普通にある。


このテーブルはエンジニアだけ触れる方がいいですね。
なんらかのタイミングと兼ね合いで動かないとか、遅いとかありうるから、
月初、

こういうテンプレートで誰々に何回送った、最後にいつ送ったというtable(upsert)
具体的にテンプレートと外部キーでどういうメールを何時に送ったかメールの内容ベタ打ちというテーブルが必要になる。なぜ内用ベタ打ちが必要かと言うと、その時独自のパラメータが今と違う可能性があるから、日付にせよ、請求金額にせよ。確かにこれを送ったという風にしないとデバッグも難しい。

どのタイミングで

htmlメールを送るならtinymceを使って管理画面から

テンプレートはプログラミング言語側のformat関数にある展開文字列使って埋め込み
件名 {}
${first_name} ${last_name}様
お世話になっております...

メールのテンプレートのパースは
pluginでやってくれるframeworkは割とあるから信用できるならそれ使う方がいい。


これが3つがないと
どういうテンプレートを
いつ送ったか、
何回送ったか、
具体的なメールの内用、
が分からなくなる。

メールのテンプレートの履歴も取っときたいなら、
テンプレート履歴用のtable作るか、

履歴用のtableを作らないならメールテンプレートtableの非正規化を許容することになるから
そのデメリットを運用でカバーになる。
テンプレートテーブルが間違いなく汚くなる。
テンプレートテーブルがテンプレート履歴テーブルも兼ねることになる。

テンプレートテーブルをupdateして、新たにtemplate tableをインサートになる。


SIerで下の企業に運用全部丸投げじゃない限りやめといた方がいいです。
メールのテンプレート戻したいとか、間違ってupdateとかよくあるので。

メールのテンプレートは運用の持ち物にして、
SE通さなくても自分たちで全部管理できるよう管理画面から触れるようにしとく。

メールのテンプレートいじるたびに
テンプレートテーブルとテンプレート履歴テーブルが
それぞれupsertとinsertされていく。
この二つはトランザクション

履歴テーブルと送った時間を付き合わせたら、どのテンプレート
が使われたのかわかる。

履歴用のテーブルいらんやんっていう人いると思いますが、
経営陣が決済や、クロージングに関するメールを戻したいとか
昔どういうテンプレート送ったかわかる？とか結構あって、
特にスタートアップやベンチャーだと経営者自体がビジネス初心者って言うことが結構あるのと
営業マン上がりとか最近やったらコミュニティビジネス上がりとか。
契約書とか商習慣的に請求書はどうこうとか疎い人も結構いる。

ITの知識あんまないって言うのが結構あって
最初必要ないって言っても、急に言い出すことって結構あって、
今のところ自分が仕事してるところはみんな急に言い出してますね。

あれってあれもできるんちゃうか？とか。

自分が最初そう言われたからそう作りました！で通るなら良いけど。

upsertな作り方の何がいいかというと、
今後メール送信を事務の仕事にするとしましょう。
その場合要件として
同じメールをもう一度送信したいという要件があったり、


ここら辺を全部OrmでSE側がDB設計分からんくても面倒見れるプラグインとかあるんならOrm使ってもいいと思います。
ただ、rails6.0でupsert_all初めて使えるようになりました！とか考えると
あったとしても導入するのは割とリスク高そうかなと思います。
それがちゃんと保守されるかという問題はありますし。

## バッチの種類

1. bash
2. nodejs
3. python
4. golang

新規のバッチで使われる事があるのはこの４つかなと。

### bash

メリット

1. Linuxなら特に何もインストールしなくても使える
2. 用意するものがなく割とすぐ書ける
3. プログラマが一度知識をつけたら、使える期間が割と長い。
4. 成熟しており、破壊的な変更が少ない。

#### Linuxなら特に何もインストールしなくても使える

新たに何か入れるなら上位の会社に色々言わないといけない
環境とかの人でも割と簡単に導入できると思います。

#### 用意するものがなくても割とすぐ書ける

新たにaptなり、dnfなりでコマンドインストールするぐらいで特に
必要なモノはありません。

#### プログラマが一度知識をつけたら、使える期間が割と長い

個人的にはこれが一番大きなメリットだと思ってて、
一度知識を身につけたら、5年後使えなくなるというのは基本的にないです。
だから基本的なコマンドのsed,awk,grep
などの具体的な使い方はほとんど暗記レベルの勢いで覚えても時間が
もったいない使い方をしたにはならないと思います。

たまに変更あるのを言うと、
ifconfigが非推奨になってネットワーク系のコマンドはipコマンドに統一とか、
mail系のコマンドがmail-utilがdebian系でもrhel系でも非推奨になったとか、
scpが非推奨になったとか。

デメリット

1. プログラミングスキルの差がかなり出る。
2. 定番のテストフレームワークがない

#### 純粋にプログラミングスキルが要求される

1. パイプという概念を理解する必要がある
2. 親プロセス、子プロセスを意識する必要がある
3. 標準出力とエラーコードを意識して書く必要がある。
4. 処理のたびにダブルクォート、バックスラッシュが外れる。
5. awkの闇が深い...
6. BSDとGNUでコマンドが違う
7. set -uをとりあえず使う
8. trapという処理が独特

ここら辺の問題回避、吸収しようとすると
高いシェルスクリプトのスキル、プログラミングスキルが要求される

##### パイプという概念を理解する必要がある

プログラミング言語に無い考え方で、
printというかechoの出力使って永遠と繋げていく
これは割と説明しづらい考え方で、
xargs使って云々とかawk使って云々が慣れの割合が多い。

ちゃんとパイプ使えるところはパイプ使わないと
処理が遅くなる。

大規模なところだと、パイプ使うなという謎ルールがあるところとか
たまにある。

##### 親プロセス、子プロセスを意識する必要がある

これを理解してないと何がまずいかと言うと、
変数と環境変数の使いわけが分からなかったり、それらのスコープが分からなくなります。

その結果全部関数の引数にするか、
.envみたいに変数と値だけ書いているファイルを用意して
awkで指定の変数の値を読み込んでみたいなブサイクな処理を組み込む事になります。

これいいんちゃうの？という人もいると思うんですが、これをやるとその都度
ファイルをreadする必要が出るから、ディスクIOがボトルネックになります。

これと同じパターンでDBに環境変数に相当するものを保存していて、
その都度selectしてデータを取り出すというのもあったりします。

Ormで言うN+1問題を作ってる事になるから件数が何百万件とか超えると相当遅い。

ここら辺はvpsだとサーバーから見てローカルでやってるところが多いからそんなに問題ならないですが、
cloudだとIOの遅延がかなり深刻になるからお金かけたからと言って解決する問題じゃなくなる。
DMMさんのブログでもオンプレからクラウドに移す時にこういう処理直したって言ってるから、
DMMさんぐらいキャッシュに余裕あるところでも考えなあかんので、ベンチャーやスタートアップは
最初からケアしといた方がいい。
一度わかれば手間が増える系でも無いので。

パイプ繋げていくとか、
、
エラーコードを返すとか、
がごちゃ混ぜになるとか、
BSDとGNUでコマンドが違うからその差を埋める方法とか、
色々人間側で考える必要があります。

今言ったやつは大病院でも大手ECサイトでも割と多くて、
潤沢なメモリやら、CPUの処理でなんとかなってるけどクラウドだと
基本的にいろんなもの切り離すからIOの問題が大きくなる。


##### 標準出力とエラーコードを意識して書く必要がある


##### 処理のたびにダブルクォート、バックスラッシュが外れる。

これバグっぽく
見えるんですが、
```bash
list=(1 2 3 4)
# プログラマ側の意図としては""の中に"1 2 3 4"と一つの引数として渡したかった。
# bash側で配列の展開するときに"が外れる
# 内部的に配列の展開するときに関数呼び出して一つずつ値を取り出してるのか。
hellofunc "${list[@]}"

一つの文字列として渡したかったら、下のようにする。
これなら配列展開しても$()で閉じられているから、ダブルクォートが勝手に展開されない。
hellofunc "$(echo $list[@])"

どうしてもメタ文字扱うときはバックスラッシュ使わないといけなくて、
それをエスケープする必要があるんですが、
これがパイプで処理されるたびに外れる。

どういうことかっていうと、

プログラミング言語でも何度も処理するならバックスラッシュたくさんいるんですが、
bashはパイプで繋いでいく以上、プログラミング言語よりもこの問題に直面しやすい。

バックスラッシュ

powershellはちゃんとダブルクォーと展開せずに渡す。

```


##### awkの闇が深い...

闇でもなんでもないけど、
細かいこと

1. awkでcsvがちゃんとパースできない。

2. awkのfor inはforeachでない。
3. UNIXはawk,linuxはgawk,debian系はmawkと方言がかなりある。

これbashでバッチ処理書いている会社でよくあるんですけど、これ本当にやめた方がいいです。
これ何が悪いかと言うと改行があったり、カンマなどの文字列が入ってくると
ちゃんとパースできないのと、csv自体に方言がかなり多いので、
それを吸収してくれるライブラリ使わないとちゃんとパースできません。
おレイリーのpython入門にcsvのパースについて


ビジネス的な要件変わってカンマや改行を含むカラムが増えただけで、
動かなくなるので。
もしやるなら、bashからpythonなりgolangなり
読んでパースした方がいいです。

どうしてもshellでやりたいならawkでなくてpowershell一択だけど、何百万レコードなら
処理たまに止まると思うんでおすすめできないです。

まず下の処理をしたらどうなるか?
```bash
# とりあえず一行処理したいので空の文字列を渡す。
echo "" | awk '
BEGIN{
  str[1]="hello"
  str[2]="world"
  str[3]="!!" 
}
{
  for(val in str){
    print val
    print str[val]
  }
}'
```

おそらくhello改行world改行!!改行

awk,でもgawkでもmawkでも同じ。
for inは値を取り出すのでなくてインデックスを取り出す。

みんながみんな
割とコレ知らない人が多いらしくて、
突っ込んでる人少ない。

バグみたいな挙動なんで使わない方が良い。
仕様を知って無いと間違いなくハマる。

mawkってあまり聞いたことと思うんですけど、
gawkの速度を上げる代わりにいろんな機能をとっぱらったのが、
mawkでmawkの方が後発なんですよ。
debian系のawkはデフォルトはmawkになっていて、
こんなの使わないとかなら良いんですけど、
何回目にでたやつを置換するとか、そういう割と使うやつも
使えなかったりするので、素直にgawk使った方がいい。

##### BSDとGNUでコマンドが違う

ほとんどの場合Gnuの方がコマンドは賢いし、バグが無いので、
Gnuコマンドを使うべき。
ただ、.bash_profileでalias gsed=sedみたいに定義することは
やめた方がいいと思います。
影響範囲が広いので思わぬバグを生む危険性がある。
例えば、関数内やコマンド内で一時的に
aliasを有効にするというのが賢い。

具体的に言いますと、こういうコード書くとか。

これならlinuxでもmacでも同じように動作するし、
aliasを関数内に閉じ込めれる。

##### set -uをとりあえず使う

未定義の変数をエラーにできる。
これもやめといた方がいいと思ってて、
未定義と空の変数を

if [ -z $VARIABLE ]; then
  echo "set VARIABLE!" >&2
  return 1
fi 

という形で弾けたり、

local VARIABLE=$ENV_VARIABLE
if [ -z $VARIABLE ]; then
 VARIABLE="default value"
fi
という形で未定義や値がなかったらセットするというのもできない。

プログラミング言語がなぜそういう作りにしてあるのか？
をガン無視のやり方なのでtypescriptで言うとtsconfig.jsonを
こねくり回すやり方。
混乱するからやめた方がいい。
やるなら関数内やデバッグ時など部分的にした方がいい。

##### trapという処理が独特

これは正直自分もあまり使いこなせて無いんですけど、
特定のプロセスがこうなりましたよという結果を
もらって処理する。
基本的にデストラクタみたいな後処理がメイン。
一時ファイルを削除とか。
これの何が問題かというと
グローバルに影響与えるので、関数内で処理
なので意図してるならともかく、基本的にtrap解除も書く必要がある。


#### 定番のテストフレームワークがない

一様テストフレームワークはある事はあるんですが、
みんなそんな使ってるのかな？というぐらい。
テスト必要なぐらいだったら、pythonとかプログラミング言語で書いてる
事が多そう。

### bash総評

tableにする

1. バグ作りやすい
2. 堅牢に作りづらい
3. 保守性も難しい

純粋に高いプログラミングスキルが必要になる。
一度ハマらないとわからない仕様が多い。
もし使うなら、googleのcoding規約があるからそれを参考に書くと良い。

### nodejs

### nodejs総評
1. バグ作りやすい
2. 堅牢に作りづらい
3. 保守性も難しい

nodejsでバッチ処理書いてますは周りで聞いたことない。
割と破壊的な変更や混乱する処理が多いので、nodejsのバックエンドが数年後に
問題になりそう。
デザイナー上がりのSEならjs得意な人も多いので、デザイン重視の会社ならアリ？
割と趣味になる。

### python

### python総評

1. バグ作りづらい
2. 堅牢はそこそこ
3. 保守性もそこそこ

とりあえず動かすが簡単な割に、混乱する仕様が少ない。
内包表記やらデコレーターやらpython独自の処理を使いまくらなければ。
ansibleやpexectなどプロビジョンに向くツールも多く、それらの完成度も高い。
かなりおすすめ。

### golang

#### 後方互換が強い

破壊的な変更が少なく
ガンガンバージョンを上げても問題が起きづらい。


### golang総評

1. バグ作りづらい
2. 堅牢に作りやすい
3. 保守性も高い

とりあえず動かすには向かないが混乱する仕様が少ない

ビジネスロジックだけ
書いててダルいが割と愚直に書くべき。
マルチモジュールとかレポジトリ周りの方針,ツール周りが心配。
googleさんも社内で使ってるらしいので、急に捨てられるはまずない。
